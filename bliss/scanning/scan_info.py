# -*- coding: utf-8 -*-
#
# This file is part of the bliss project
#
# Copyright (c) 2015-2020 Beamline Control Unit, ESRF
# Distributed under the GNU LGPLv3. See LICENSE for more info.

"""
Contains helper to manage the `scan_info` metadata provided inside each scans.

The `scan_info` is dictionary compounded by basic python types to provides
metadata relative to a scan.

Most of the fields are automatically generated by BLISS.

But the dictionary can be feed with extra information, which can be normalized
or not. For normalized data, the class `ScanInfo` provides few helpers to
update them.

Acquisition chain
=================

The `scan_info` describe the acquisition chain of the scan.

It contains:

- Top master device description
    - An independent acquisition chains
    - It contains the a set of involved devices
- Device description
    - An acquisition object part of the chain
    - List of sub devices triggered (if some)
    - List of the channels generated
- Channel description
    - Channel for data generated by the scan
    - Provides channel metadata

Here is a representation of the `acquisition_chain` structure:


.. code-block:: python

    scan_info = {
        "acquisition_chain": {
            TOP_MASTER_NAME_1: {
                "devices": [DEVICE_MASTER_ID, DEVICE_SLAVE_ID, ...]
            },
            ...
        },
        "devices": {
            DEVICE_MASTER_ID: {
                "channels": [CHANNEL_PATH_1, CHANNEL_PATH_2, ...],
                "triggered_devices": [DEVICE_SLAVE_ID, ...]
                ...
            },
            DEVICE_SLAVE_ID: {
                "channels": [CHANNEL_PATH_3, CHANNEL_PATH_4, ...]
                ...
            },
        },
        "channels": {
            CHANNEL_PATH_1: {...},
            CHANNEL_PATH_2: {...},
            CHANNEL_PATH_3: {...},
            CHANNEL_PATH_4: {...},
            ...
        },
    }

You better not to do assumption on the we way the devices/channels keys are
generated. But for now that's the only way to reach there names.

For now:

- `DEVICE_ID` are generated by `UNIQUE_ID + ":" + device_name`
    - Example: `31614654:timer`
- `CHANNEL_PATH` are generated usign the parent names (excuding the top master) separated by ":".
    - Example: `timer:elapsed_time`

So reaching name for devices or channels can be done the following way:
`name = key.rsplit(":", 1)[-1]`.

Channel metadata
================

Each channel metadata are stored per channel names in the filed `channels` of
the scan_info.

The following metadata are automatically generated.

- `display_name` (optional, str): Expected displayed name
- `unit` (optional, str): SI unit used by the data
- `dim` (mandatory, int): Dimensionality of the data
                          (0: scalar, 1: 1D data, 2: 2D data)

There is other metadata which can be feed by the scan designers.
Take a look at :meth:`ScanInfo.set_channel_meta`.


API
===
"""

import typing
import typeguard
import numbers


class ScanInfo(dict):
    """
    Holder of metadata associated to a scan.

    It provides a key-value API to store metadata plus helper to feed this
    dictionary.

    It is exposed as a normal dictionary by Redis scan nodes.
    """

    def __init__(self):
        self._scan_info = self

    def _set_scan_info(self, scan_info):
        """This method and attribute is a trick to make the backward compatible
        implementation of ScanInfoFactory easy. This have to be removed together
        with ScanInfoFactory in few version.

        Introduced with BLISS 1.7
        """
        self._scan_info = scan_info

    @staticmethod
    def normalize(scan_info):
        """Returns a ScanInfo initialized from a raw object"""
        if isinstance(scan_info, ScanInfo):
            return scan_info
        result = ScanInfo()
        if scan_info is None:
            pass
        elif isinstance(scan_info, dict):
            result.update(scan_info)
        else:
            assert False
        return result

    @typeguard.typechecked
    def set_channel_meta(
        self,
        name: str,
        start: typing.Optional[numbers.Real] = None,
        stop: typing.Optional[numbers.Real] = None,
        min: typing.Optional[numbers.Real] = None,
        max: typing.Optional[numbers.Real] = None,
        points: typing.Optional[numbers.Integral] = None,
        axis_points: typing.Optional[numbers.Integral] = None,
        axis_kind: typing.Optional[str] = None,
        group: typing.Optional[str] = None,
        axis_id: typing.Optional[numbers.Integral] = None,
        axis_points_hint: typing.Optional[numbers.Integral] = None,
    ):
        """
        Define metadata relative to a channel name

        Arguments:
            name: Name of the channel
            start: Start position of the axis
            stop: Stop position of the axis
            min: Minimal value the channel can have
            max: Minimal value the channel can have
            points: Amount of total points which will be transmitted by this channel
            axis_points: Amount of points for the axis (see scatter below)
            axis_kind: Kind of axis. It is used to speed up solid rendering in
                GUI. Can be one of:

                - `forth`: Move from start to stop always
                - `backnforth`: Move from start to stop to start
                - `step`: The motor position is discrete. The value can be used\
                  to group data together.

            group: Specify a group for the channel. All the channels from the
                same group are supposed to contain the same amount of item at
                the end of the scan. It also can be used as a hint for
                interactive user selection.
            axis_id: Index of the axis in the scatter. 0 is the fastest.
            axis_points_hint: Number of approximate points expected in the axis
                when this number of points is not regular
        """
        channels = self._scan_info.setdefault("channels", {})
        assert axis_kind in set([None, "forth", "backnforth", "step"])
        meta = channels.setdefault(name, {})
        if start is not None:
            meta["start"] = start
        if stop is not None:
            meta["stop"] = stop
        if min is not None:
            meta["min"] = min
        if max is not None:
            meta["max"] = max
        if points is not None:
            meta["points"] = points
        if axis_points is not None:
            meta["axis-points"] = axis_points
        if axis_id is not None:
            assert axis_id >= 0
            meta["axis-id"] = axis_id
        if axis_kind is not None:
            meta["axis-kind"] = axis_kind
        if group is not None:
            meta["group"] = group
        if axis_points_hint is not None:
            meta["axis-points-hint"] = axis_points_hint

    @typeguard.typechecked
    def add_scatter_plot(
        self,
        name: typing.Optional[str] = None,
        x: typing.Optional[str] = None,
        y: typing.Optional[str] = None,
        value: typing.Optional[str] = None,
    ):
        """
        Add a scatter plot definition to this `scan_info`.

        This can be used as default plot for the scan.

        Arguments:
            name: Unique name for the plot. If not defined a default plot name
                is used.
            x: Channel name for the x-axis
            y: Channel name for the y-axis
            value: Channel name for the data value
        """
        plots = self._scan_info.setdefault("plots", [])
        if not isinstance(plots, list):
            raise TypeError("The 'plots' metadata is corrupted. A list is expected.")

        item = {"kind": "scatter"}
        if x is not None:
            item["x"] = x
        if y is not None:
            item["y"] = y
        if value is not None:
            item["value"] = value

        items = []
        if len(item) > 1:
            items.append(item)

        plot = {"kind": "scatter-plot", "items": items}
        if name is not None:
            plot["name"] = name

        plots.append(plot)

    def set_sequence_info(self, scan_count: typing.Optional[int] = None):
        """
        Set extra-info for a sequence.

        Arguments:
            scan_count: Set it if you know the amount of scan which will be part
                        your sequence. THis can be used to know client side the
                        progress of the sequence.
        """
        info = self._scan_info.setdefault("sequence-info", {})
        info["scan-count"] = int(scan_count)

    def _get_channels_dict(self, acq_object, channels_dict):
        scalars = channels_dict.setdefault("scalars", [])
        spectra = channels_dict.setdefault("spectra", [])
        images = channels_dict.setdefault("images", [])
        already_read = set([])

        for acq_chan in acq_object.channels:
            fullname = acq_chan.fullname
            if fullname in already_read:
                continue
            already_read.add(fullname)
            shape = acq_chan.shape
            if len(shape) == 0 and fullname not in scalars:
                scalars.append(fullname)
            elif len(shape) == 1 and fullname not in spectra:
                spectra.append(fullname)
            elif len(shape) == 2 and fullname not in images:
                images.append(fullname)

        return channels_dict

    def _device_fullname(self, acq_obj):
        """Returns the full name of this device in order to make it unique.
        """
        return f"{id(acq_obj)}:{acq_obj.name}"

    def set_acquisition_chain_info(self, acq_chain):
        """
        Go through this acquisition chain, group acquisition channels by master
        and data shape.
        """
        from bliss.scanning.chain import AcquisitionMaster

        tree = acq_chain.tree

        chain_dict = {}
        for path in tree.paths_to_leaves():
            master = None
            # path[0] is root
            for acq_object in path[1:]:
                # it is mandatory to find an acq. master first
                if isinstance(acq_object, AcquisitionMaster):
                    if master is None or acq_object.parent is None:
                        master = acq_object.name
                        channels = chain_dict.setdefault(master, {"master": {}})
                        self._get_channels_dict(acq_object, channels["master"])
                        continue
                self._get_channels_dict(acq_object, channels)
        self._scan_info["acquisition_chain"] = chain_dict

        # Update devices keys
        devices = self._scan_info.setdefault("devices", {})
        for top_master_node in tree.children(tree.root):
            top_master = top_master_node.identifier
            if top_master is None:
                continue
            top_master_devices = self._scan_info["acquisition_chain"][
                top_master.name
            ].setdefault("devices", [])
            for acq_dev in tree.expand_tree(top_master):
                if acq_dev is None:
                    continue
                acq_dev_name = self._device_fullname(acq_dev)
                top_master_devices.append(acq_dev_name)
                device_info = devices.setdefault(acq_dev_name, {})
                triggered_devices = [
                    self._device_fullname(d.identifier) for d in tree.children(acq_dev)
                ]
                if len(triggered_devices) > 0:
                    device_info["triggered_devices"] = triggered_devices
                channel_names = [c.fullname for c in acq_dev.channels]
                if len(channels) > 0:
                    device_info["channels"] = channel_names

        # Update channels key
        channels = self._scan_info.setdefault("channels", {})
        for path in tree.paths_to_leaves():
            for acq_object in path[1:]:
                for acq_chan in acq_object.channels:
                    fullname = acq_chan.fullname
                    meta = channels.setdefault(fullname, {})
                    unit = acq_chan.unit
                    if unit is not None:
                        meta["unit"] = unit
                    display_name = acq_chan.short_name
                    if display_name is not None:
                        meta["display_name"] = display_name
                    shape = acq_chan.shape
                    if shape is not None:
                        meta["dim"] = len(shape)

        # Feed Lima ROIs into the scan_info
        rois = {}
        from bliss.controllers.lima.roi import RoiCounters
        from bliss.controllers.lima.roi import RoiProfileController

        for path in tree.paths_to_leaves():
            for acq_object in path[1:]:
                device = acq_object.device
                already_processed = set()

                if not isinstance(device, (RoiCounters, RoiProfileController)):
                    continue
                for roi_counter in device.counters:
                    roi_name = roi_counter.roi_name

                    # Only deal once with each ROIs
                    if roi_name in already_processed:
                        continue
                    already_processed.add(roi_name)

                    # Store ROI metadata
                    basename = roi_counter.fullname.rsplit(":", 1)[0]
                    fullname = f"{basename}:{roi_name}"
                    roi = device.get(roi_name)
                    rois[fullname] = roi.to_dict()
        self._scan_info["rois"] = rois
