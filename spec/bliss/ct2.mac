#========================================================================
# This file is part of the bliss project
#
# Copyright (c) 2015-2019 Beamline Control Unit, ESRF
# Distributed under the GNU LGPLv3. See LICENSE for more info.
#=====================================================================


need stlist


#=====================================================================
#     DEBUG / PROFILING
#=====================================================================
if (!(whatis("__ct2_profile")  & 2)) rdef __ct2_profile \'#$*\'

def ct2_profiling '{
    if ((whatis("__ct2_profile")>>16) <= 5) { # just a # sign -> off
        rdef __ct2_profile "eprintf(\"... CT2: %s %s %f \", FnId, addon, _ct2_y = ((_ct2_x = time()) - CT2_MAC_HDW[ctrl_dev][\"last\"])); CT2_MAC_HDW[ctrl_dev][\"last\"] = _ct2_x; if(_ct2_y > 0.01) eprintf(\"[too long!] \"); addon=\"\" ; eprint"
        print "CT2 profiling is ON"
    } else {
        rdef __ct2_profile \'#$*\'
        print "CT2 profiling is OFF"
    }
}'

#=====================================================================
#     CONFIG
#=====================================================================

def ct2_config(cnum, type, unit, module, chan) '{
    local FnId addon; FnId="ct2_config"
    local mne ctrl_dev
    global CT2_MAC_HDW[]
    global CT2_MAC_LIST[]
    ctrl_dev = ct2_ADDR

    addon =sprintf(" cnum[%s] type[%s] unit[%s] module[%s] chan[%s] ", cnum, type, unit, module, chan) 
    __ct2_profile 
        
    if (type == "ctrl") {
        if  (unit <= CT2_MAC_HDW["last_config_unit"])   {
    
            __ct2_profile " RESET globals" 
            unglobal CT2_MAC_HDW; global CT2_MAC_HDW[]
            CT2_MAC_HDW["timer_list"] = ""
            unglobal CT2_MAC_HDW_LAST; global CT2_MAC_HDW_LAST[]
            list_init CT2_MAC_LIST
        }
    
        CT2_MAC_HDW["last_config_unit"] = unit

        printf("CT2: Using P201 \"%s\" counters\n", ctrl_dev)
        list_add(CT2_MAC_LIST, ctrl_dev)
        list_setpar(CT2_MAC_LIST, ctrl_dev, "unit", unit)
        list_setpar(CT2_MAC_LIST, ctrl_dev, "master_unit", -1)
        list_setpar(CT2_MAC_LIST, ctrl_dev, "int_cnt", 0)
        CT2_MAC_HDW[ctrl_dev]["slaves"] = ""
        return
    }
    
    if (type == "cnt")  {
        if (chan == 0) {
            mne = cnt_mne(cnum)
            local timer_list, sep
            printf("CT2: Configuring \"%s\" as timer\n", mne)
            list_setpar(CT2_MAC_LIST, ctrl_dev, "int_cnt", 11)
            list_setpar(CT2_MAC_LIST, ctrl_dev, "master_unit", unit)
            timer_list = CT2_MAC_HDW["timer_list"]
            sep = length(timer_list) ? " " : ""
            timer_list = sprintf("%s%s%s", timer_list, sep, mne)
            CT2_MAC_HDW["timer_list"] = timer_list
            return
        }
    
        return
    }
    printf("CT2: WARNING unknow type=%s, unit=%s\n", type, unit)
    return ".error."
}'


#=====================================================================
#     CMD
#=====================================================================

def ct2_cmd(cnum, key, p1, p2) '{
    local FnId addon; FnId="ct2_cmd"
    local chan ctrl_dev
    global CT2_MAC_HDW_LAST[]

    addon =sprintf(" cnum[%s] key[%s] p1[%s] p2[%s] ", cnum, key, p1, p2) 
    __ct2_profile 
    
    
    ctrl_dev = ct2_ADDR
    if (cnum != "..")
        chan = counter_par(cnum, "channel")
    if (key == "get_status") {
        return ct2_get_status(cnum, ctrl_dev, chan)
    } else if (key == "prestart_all") {
        return ct2_prestart_all(ctrl_dev)
    } else if (key == "start_one") {
        return ct2_start_one(cnum, ctrl_dev, chan, p1, p2)
    } else if (key == "counts") {
        return ct2_counts(cnum, ctrl_dev, chan, p1)
    } else if (key == "halt_one") {
        # nothing to do
    } else if (key == "halt_all") {
        tango_io(ctrl_dev, "stop_acq")
		__ct2_profile key " stop_acq "
    } else {
        printf("CT2: %s WARNING: ignored: %s\n", FnId, key)
    }
}'

#---------------------------------------------------------------------
#---------------------------------------------------------------------
def ct2_get_status(cnum, ctrl_dev, chan) '{
    local is_running, nb_timers, timer_list[], i
    nb_timers = split(CT2_MAC_HDW["timer_list"], timer_list)
    for (i = 0; i < nb_timers; i++) {
        local timer_mne, timer_cnum, timer_dev
        timer_mne = timer_list[i]
        timer_cnum = cnt_num(timer_mne)
        timer_dev = counter_par(timer_cnum, "address")
        is_running = ct2_get_timer_status(timer_cnum, timer_dev, 0)
        if (is_running)
            return 1
    }
    return 0
}'

#---------------------------------------------------------------------
#---------------------------------------------------------------------
def ct2_get_timer_status(cnum, ctrl_dev, chan) '{
    local FnId addon; FnId="ct2_get_timer_status"
    local is_running
    __ct2_profile "(trace 1)"
    is_running = (tango_get(ctrl_dev, "acq_status") == "Running")
    __ct2_profile "(trace 2)"
    CT2_MAC_HDW[ctrl_dev]["running"] = is_running
    return is_running
}'

#---------------------------------------------------------------------
#---------------------------------------------------------------------
def ct2_prestart_all(ctrl_dev) '{
    CT2_MAC_HDW[ctrl_dev]["acq_channels"] = ""
    CT2_MAC_HDW[ctrl_dev]["nb_channels"] = 0
    CT2_MAC_HDW_LAST[ctrl_dev]["valid"] = 0
}'

#---------------------------------------------------------------------
#---------------------------------------------------------------------
def ct2_start_one(cnum, ctrl_dev, chan, p1, p2) '{
    local FnId addon; FnId="ct2_start_one"
    __ct2_profile "(trace 1)" 
    if (chan != 0) {
        return ct2_start_counter_chan(cnum, ctrl_dev, chan, p1, p2)
    } else {
        return ct2_start_timer_chan(cnum, ctrl_dev, chan, p1, p2)
    }
}'

#---------------------------------------------------------------------
#---------------------------------------------------------------------
def ct2_start_counter_chan(cnum, ctrl_dev, chan, p1, p2) '{
    local FnId addon; FnId ="ct2_start_counter_chan"
    local acq_chan, sep, master_idx, master_ctrl, slaves, cnt_idx
    local cnt_master, master_ctrl_master, master_ctrl_unit

    acq_chan = CT2_MAC_HDW[ctrl_dev]["acq_channels"]
    sep = length(acq_chan) ? " " : ""
    acq_chan = sprintf("%s%s%d", acq_chan, sep, chan)
    CT2_MAC_HDW[ctrl_dev]["acq_channels"] = acq_chan
    cnt_idx = CT2_MAC_HDW[ctrl_dev]["nb_channels"]++
    counter_par(cnum, "counter_idx", cnt_idx, "add")
    
    cnt_master = list_getpar(CT2_MAC_LIST, ctrl_dev, "master_unit")
    if (cnt_master != -1)
        return

    master_idx = int(counter_par(cnum, "master"))
    master_ctrl = list_item(CT2_MAC_LIST, master_idx + 1)
    if (master_ctrl == -1) {
        printf("CT2: %s ERROR: CT2 %s master parameter is invalid: %s\n", \
               FnId, ctrl_dev, master_idx)
        return ".error."
    }

    master_ctrl_master = list_getpar(CT2_MAC_LIST, master_ctrl, "master_unit")
    master_ctrl_unit = list_getpar(CT2_MAC_LIST, master_ctrl, "unit")
    if (master_ctrl_master!= master_ctrl_unit) {
        printf("CT2: %s ERROR: CT2 %s master parameter points to a non-master device %s\n", \
               FnId, ctrl_dev, master_ctrl)
        return ".error."
    }

    list_setpar(CT2_MAC_LIST, ctrl_dev, "master_unit", master_ctrl_unit)
    slaves = CT2_MAC_HDW[master_ctrl]["slaves"]
    sep = length(slaves) ? " " : ""
    slaves = sprintf("%s%s%s", slaves, sep, ctrl_dev)
    CT2_MAC_HDW[master_ctrl]["slaves"] = slaves
}'

#-------------------------------------------------------------------
#-------------------------------------------------------------------
def ct2_start_timer_chan(cnum, ctrl_dev, chan, p1, p2) '{
    local i nb_timers timer_list[] mne

    ct2_prepare_timer_chan_and_slaves(cnum, ctrl_dev, chan, p1, p2)

    # all the timers are started at once, do nothing if not the last
    nb_timers = split(CT2_MAC_HDW["timer_list"], timer_list)
    mne = cnt_mne(cnum)
    if (mne != timer_list[nb_timers - 1])
        return

    # start all timers in reverse order
    for (i = nb_timers - 1; i >= 0; i--) {
        local timer_mne, timer_cnum, timer_dev
        timer_mne = timer_list[i]
        timer_cnum = cnt_num(timer_mne)
        timer_dev = counter_par(timer_cnum, "address")
        ct2_start_timer_chan_and_slaves(timer_cnum, timer_dev, 0, p1, p2)
    }
}'

#---------------------------------------------------------------------
#---------------------------------------------------------------------
def ct2_prepare_timer_chan_and_slaves(cnum, ctrl_dev, chan, p1, p2) '{
    local FnId addon; FnId ="ct2_prepare_timer_chan_and_slaves"
    local nb_ctrls, ctrl_list[], i, j, dev, is_master
    local factor, acq_mode, acq_chan_list[]

    nb_ctrls = split(CT2_MAC_HDW[ctrl_dev]["slaves"], ctrl_list)
    ctrl_list[nb_ctrls++] = ctrl_dev
    
    for (i = 0; i < nb_ctrls; i++) {
        local acq_mode
        dev = ctrl_list[i]
        is_master = (dev == ctrl_dev)
        factor = counter_par(cnum, "scale")
        acq_mode = is_master ? "IntTrigReadout" : "ExtGate"
        tango_put(dev, "timer_freq", factor)
        tango_put(dev, "acq_mode", acq_mode)
        tango_put(dev, "acq_point_period", 0)
        tango_put(dev, "acq_expo_time", p1)
        __ct2_profile "start_one" " chan == 0 tango_put expo time"

        split(CT2_MAC_HDW[dev]["acq_channels"], acq_chan_list)
        tango_put(dev, "acq_channels", acq_chan_list)
        __ct2_profile "start_one" " tango_put acq_channels"

        # store acq_channels_data_indexes for standard counters
        tango_get(dev, "acq_channels_data_indexes", acq_chan_list)
        __ct2_profile "start_one" " tango_get acq_channels_data_indexes"
        for (j in acq_chan_list)
            CT2_MAC_HDW[dev][sprintf("idx_%d", j)] = acq_chan_list[j]

        tango_put(dev, "acq_nb_points", 1)
        __ct2_profile "start_one" " tango_put acq_nb_points"
        
        tango_io(dev, "prepare_acq")
        __ct2_profile "start_one" " tango_io prepare_acq"
    }
}'

#---------------------------------------------------------------------
#---------------------------------------------------------------------
def ct2_start_timer_chan_and_slaves(cnum, ctrl_dev, chan, p1, p2) '{
    local FnId addon; FnId="ct2_start_timer_chan_and_slaves"
    local nb_ctrls, ctrl_list[], i, dev

    nb_ctrls = split(CT2_MAC_HDW[ctrl_dev]["slaves"], ctrl_list)
    ctrl_list[nb_ctrls++] = ctrl_dev
    
    for (i = 0; i < nb_ctrls; i++) {
        dev = ctrl_list[i]
        tango_io(dev, "start_acq")
        __ct2_profile "start_one" " tango_io start_acq"
    }
}'

#---------------------------------------------------------------------
#---------------------------------------------------------------------
# counter -> p1
#   0x01 : This scaler is accumulating seconds
#   0x10 : This scaler is first of several in the unit
#   0x2000000 : This is a NAC_CNTR

def ct2_counts(cnum, ctrl_dev, chan, p1) '{
    local FnId addon; FnId="ct2_counts"
    local cnt_idx, arr_key
    __ct2_profile  "(trace 1)"
    if (!CT2_MAC_HDW_LAST[ctrl_dev]["valid"]) {
        local int_cnt, val, cnt_i
        tango_get(ctrl_dev, "counters", val)
        int_cnt = list_getpar(CT2_MAC_LIST, ctrl_dev, "int_cnt")

        if (val[int_cnt - 1] != 0) {
            addon=sprintf("  ctrl_dev[%s] int_cnt[%s] chan[%s] cnt_idx[%s] p1[%s] ", ctrl_dev, int_cnt, chan, cnt_idx, p1)
            __ct2_profile " valid tango_get counters (trace 1)"
            cnt_idx = (chan ? chan : int_cnt) - 1
            return val[cnt_idx]
        }


        addon=sprintf("  ctrl_dev[%s] int_cnt[%s] chan[%s] cnt_idx[%s] p1[%s] ", ctrl_dev, int_cnt, chan, cnt_idx, p1)
        __ct2_profile " valid tango_get counters (trace 2)"

        TANGO_ERR = -1
        tango_get(ctrl_dev, "data", val)
        __ct2_profile " valid tango_get data "
        if (TANGO_ERR != "0")
            return -1
        for (cnt_i in val)
            CT2_MAC_HDW_LAST[ctrl_dev][cnt_i] = val[cnt_i]
        CT2_MAC_HDW_LAST[ctrl_dev]["valid"] = 1
    }
    # use acq_channels_data_indexes for standard counters, nb_channels for timers
    cnt_idx = counter_par(cnum, "counter_idx")
    arr_key = chan ? sprintf("idx_%d", cnt_idx) : "nb_channels"
    cnt_idx = CT2_MAC_HDW[ctrl_dev][arr_key]
    return CT2_MAC_HDW_LAST[ctrl_dev][cnt_idx]
}'

#-------------------------------------------------------------------
#-------------------------------------------------------------------
def ct2_get(cnum, key, val_arr) '{
    local FnId addon; FnId="ct2_get"
    local ctrl_dev arr_keys

    addon =sprintf(" cnum[%s] key[%s] ", cnum, key) 
    __ct2_profile 


    ctrl_dev = counter_par(cnum, "address")
    if (key == "?") {
        printf("%s\n%s\n%s\n", \
	       "acq_mode, acq_status, timer_freq, acq_nb_points", \
	       "acq_expo_time, acq_point_period, last_point_nb", \
	       "acq_channels, counters, latches, data")
	return
    }
    arr_keys = " acq_channels counters latches data "
    if (index(arr_keys, sprintf(" %s ", key)) > 0) {
        return tango_get(ctrl_dev, key, val_arr)
    } else {
        return tango_get(ctrl_dev, key)
    }
}'

#---------------------------------------------------------------------
#---------------------------------------------------------------------
def ct2_put(cnum, key, val) '{
    local FnId addon; FnId="ct2_put"
    local ctrl_dev mode_str

    addon =sprintf(" cnum[%s] key[%s] val[%s] ", cnum, key, val) 
    __ct2_profile 

    ctrl_dev = counter_par(cnum, "address")
    if (key == "?") {
        printf("%s\n%s\n%s\n", \
	       "acq_mode, acq_status, timer_freq, acq_nb_points", \
	       "acq_expo_time, acq_point_period, last_point_nb", \
	       "acq_channels")
	return
    }
    return tango_put(ctrl_dev, key, val)
}'

#---------------------------------------------------------------------
#---------------------------------------------------------------------
def ct2_io(cnum, cmd) '{
    local FnId addon; FnId="ct2_io"
    local ctrl_dev mode_str val val_arr[]

    addon =sprintf(" cnum[%s] cmd[%s] ", cnum, cmd) 
    __ct2_profile 

    ctrl_dev = counter_par(cnum, "address")
    if (cmd == "?") {
        printf("%s\n%s\n", \
	       "prepare_acq, start_acq, stop_acq, trigger_point", \
	       "trigger_latch")
        return
    }
    tango_io(ctrl_dev, cmd)
}'

