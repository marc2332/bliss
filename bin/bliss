#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of the bliss project
#
# Copyright (c) 2016 Beamline Control Unit, ESRF
# Distributed under the GNU LGPLv3. See LICENSE for more info.

"""
Usage: bliss [--log-level=<log_level>] [(-s | --session)] <name>...
       bliss [--show-sessions]
       bliss
       bliss (-h | --help)
Options:
    --log-level=<log_level>       Log level [default: WARN].
    --show-sessions               Display available sessions.
    -s, --session                 Starts with some session(s).
    -h, --help                    Show this screen.
"""
import sys
import os
import logging
import gevent
import docopt
from ptpython import repl
from ptpython.prompt_style import PromptStyle
from prompt_toolkit.eventloop.base import EventLoop, INPUT_TIMEOUT
from prompt_toolkit.terminal.vt100_input import InputStream
from prompt_toolkit.eventloop.posix_utils import PosixStdinReader
from prompt_toolkit.eventloop.posix import call_on_sigwinch, DummyContext, in_main_thread
from prompt_toolkit.eventloop.select import fd_to_int
from prompt_toolkit.token import Token
from gevent import select
import time
import signal
import functools
from bliss.shell import initialize, ScanListener, REPL_CONFIGS
from bliss.config import static

class GeventEventLoop(EventLoop):
    def __init__(self, *args, **kwargs):
        super(EventLoop, self).__init__()
        self.readers = dict()
        self._running = True
        self._schedule_pipe_read,self._schedule_pipe_write = os.pipe()
        self._calls_from_executor = list()
        self._callbacks = None
        self._winch_callback_done = True

    def run(self, stdin, callbacks):
        inputstream = InputStream(callbacks.feed_key)
        stdin_reader = PosixStdinReader(stdin.fileno())
        self._callbacks = callbacks

        if in_main_thread():
            ctx = call_on_sigwinch(self.received_winch)
        else:
            ctx = DummyContext()
        
        select_timeout = INPUT_TIMEOUT
        with ctx:
            while self._running:
              r, _, _ = select.select([stdin.fileno(),self._schedule_pipe_read],
                                      [], [],select_timeout)
              if stdin.fileno() in r:
                  select_timeout = INPUT_TIMEOUT
                  data = stdin_reader.read()
                  inputstream.feed(data)
                  if stdin_reader.closed:
                      break
              elif self._schedule_pipe_read in r:
                  os.read(self._schedule_pipe_read,8192)
                  while True:
                      try:
                          task = self._calls_from_executor.pop(0)
                      except IndexError:
                          break
                      else:
                          task()
              else:
                  # timeout
                  inputstream.flush()
                  callbacks.input_timeout()
                  select_timeout = None

        self._callbacks = None

    def received_winch(self):
        def process_winch():
            if self._callbacks:
                self._callbacks.terminal_size_changed()
            self._winch_callback_done = True

        if self._winch_callback_done:
            self._winch_callback_done = False
            self.call_from_executor(process_winch)

    def stop(self):
        """
        Stop the `run` call. (Normally called by
        :class:`~prompt_toolkit.interface.CommandLineInterface`, when a result
        is available, or Abort/Quit has been called.)
        """
        self._running = False
        try:
            os.write(self._schedule_pipe_write,'x')
        except (AttributeError, IndexError, OSError):
            pass

    def close(self):
        """
        Clean up of resources. Eventloop cannot be reused a second time after
        this call.
        """
        self.stop()
        for reader in self.readers.values():
            reader.kill()
        self.readers = dict()
        self._callbacks = None

    def add_reader(self, fd, callback):
        """
        Start watching the file descriptor for read availability and then call
        the callback.
        """
        fd = fd_to_int(fd)
        self.readers[fd] = gevent.get_hub().loop.io(fd, 1)
        self.readers[fd].start(callback)

    def remove_reader(self, fd):
        """
        Stop watching the file descriptor for read availability.
        """
        fd = fd_to_int(fd)
        task = self.readers.pop(fd,None)
        if task is not None:
            task.kill()
        
    def run_in_executor(self, callback):
        """
        Run a long running function in a background thread. (This is
        recommended for code that could block the event loop.)
        Similar to Twisted's ``deferToThread``.
        """
        self.call_from_executor(callback)

    def call_from_executor(self, callback, _max_postpone_until=None):
        """
        Call this function in the main event loop. Similar to Twisted's
        ``callFromThread``.

        :param _max_postpone_until: `None` or `datetime` instance. For interal
            use. If the eventloop is saturated, consider this task to be low
            priority and postpone maximum until this timestamp. (For instance,
            repaint is done using low priority.)
        """
        if _max_postpone_until is None:
            def start_executor():
                gevent.spawn(callback)
            self._calls_from_executor.append(start_executor)
        else:
            def postpone():
                sleep_time = _max_postpone_until - time.time()
                if sleep_time > 0:
                    gevent.sleep(sleep_time)
                callback()
            self._calls_from_executor.append(postpone)
        try:
            os.write(self._schedule_pipe_write,'x')
        except (AttributeError, IndexError, OSError):
            pass


class BlissPrompt(PromptStyle):
    """
    A prompt resembling the IPython prompt.

    To activate it, simply set it in the shell configure method:

    def configure(repl):
        repl.prompt_style = 'bliss'
    """
    def __init__(self, python_input, prompt_name):
        self.python_input = python_input
        self.prompt_name = prompt_name

    def in_tokens(self, cli):
        return [
            (Token.In, self.prompt_name),
            (Token.In, ' ['),
            (Token.In.Number, '%s' % self.python_input.current_statement_index),
            (Token.In, ']: '),
        ]

    def in2_tokens(self, cli, width):
        return [
            (Token.In, '...: '.rjust(width)),
        ]

    def out_tokens(self, cli):
        return [
            (Token.Out, '{0:>{width}}'.format('Out', width=len(self.prompt_name))),
            (Token.Out, ' ['),
            (Token.Out.Number, '%s' % self.python_input.current_statement_index),
            (Token.Out, ']:'),
            (Token, ' '),
        ]    


CURRENT_TASK = None

def main():
    try:
        # Parse arguments, use file docstring as a parameter definition
        arguments = docopt.docopt(__doc__)
        sessions_name = arguments['<name>']
    except docopt.DocoptExit as e:
        print e.message
    else:
        log_level = getattr(logging, arguments['--log-level'].upper())
        fmt = '%(levelname)s %(asctime)-15s %(name)s: %(message)s'
        logging.basicConfig(level=log_level, format=fmt)

        if arguments['--show-sessions']:
            config = static.get_config()
            print 'Session name(s):'
            for name in config.names_list:
                c = config.get_config(name)
                if c.get('class') != 'Session': continue
                if c.get_inherited('plugin') != 'session': continue
                print ' '*4,name
            exit(0)
        repl.create_eventloop = GeventEventLoop

        scan_listener = ScanListener()

        user_ns, sessions = initialize(*sessions_name)

        if sessions_name:
            session_id  = '_'.join(sessions_name)
            session_title = u'Bliss shell ({0})'.format(', '.join(sessions_name))
            history_filename = ".%s_%s_history" % (os.path.basename(sys.argv[0]), session_id)
            prompt_name = sessions_name[0].upper()
        else:
            session_id = 'unnamed'
            session_title = u'Bliss shell'
            history_filename = ".%s_history" % os.path.basename(sys.argv[0])
            prompt_name = 'BLISS'
        history_filename = os.path.join(os.environ["HOME"], history_filename)

        def patch_repl(repl):
            repl.get_globals()['REPL'] = repl
            prev_execute = repl._execute
            def wrapped_f(self,*args, **kwargs):
                try:
                    return prev_execute(self,*args,**kwargs)
                except:
                    return sys.exc_info()

            def patched_execute(*args, **keys):
                global CURRENT_TASK
                CURRENT_TASK = gevent.spawn(wrapped_f, *args, **keys)
                try:
                    try:
                        return_value = CURRENT_TASK.get()
                        if isinstance(return_value, tuple) and len(return_value) >= 3:
                            if isinstance(return_value[1], (BaseException, Exception)):
                                raise return_value[0], return_value[1], return_value[2]
                    except gevent.Timeout as e:  #gevent.Timeout  doesn't inherit from Exception.
                        repl._handle_exception(*args)
                finally:
                    CURRENT_TASK = None
            repl._execute = patched_execute
            repl.all_prompt_styles['bliss'] = BlissPrompt(repl, prompt_name)

            for configure in REPL_CONFIGS:
                try:
                    configure(repl)
                except:
                    sys.excepthook(*sys.exc_info())
                

        def stop_current_task(signum, frame, exception=gevent.GreenletExit):
            if CURRENT_TASK:
                CURRENT_TASK.kill(block=False, exception=exception)
        signal.signal(signal.SIGINT, functools.partial(stop_current_task, exception=KeyboardInterrupt))
        signal.signal(signal.SIGTERM, stop_current_task)

        repl.embed(user_ns, None, vi_mode=False, history_filename=history_filename,
                   configure=patch_repl, title=session_title)


if __name__ == '__main__':
    main()
